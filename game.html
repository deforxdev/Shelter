<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game - Shelter</title>
    <link rel="stylesheet" href="game.css">
    <link href="https://fonts.googleapis.com/css2?family=Kenia&family=Kelly+Slab&family=Source+Sans+Pro&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-page">
        <!-- Background -->
        <div class="background"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-bar"></div>
            <div class="header-gradient"></div>
            <div class="header-logo">
                <img src="Assets/Component 1 (1).svg" alt="Shelter" class="header-icon">
                <span class="header-title">Shelter</span>
            </div>
        </header>
        
    
        
        <!-- Main Content -->
        <main class="main-content">
            <!-- Left Panel - Players Grid -->
            <div class="players-panel">
                <div class="players-grid" id="players-grid">
                    <!-- Players will be generated here -->
                </div>
                <div class="pagination">
                    <button class="page-btn prev-btn" id="prev-page">&lt;</button>
                    <span class="page-info" id="page-info">1 / 2</span>
                    <button class="page-btn next-btn" id="next-page">&gt;</button>
                </div>
            </div>
            
            <!-- Center Panel - Current Speaker -->
            <div class="center-panel">
                <h2 class="bunker-slots">–ú—ñ—Å—Ü—å –≤ –±—É–Ω–∫–µ—Ä—ñ <span id="bunker-slots">0</span></h2>
                <h3 class="round-info">–†–∞—É–Ω–¥ <span id="current-round">1</span></h3>
                
                <div class="speaker-frame">
                    <div class="speaker-video">
                        <video autoplay playsinline id="speaker-video"></video>
                    </div>
                    <span class="speaker-name" id="speaker-name">Qesa</span>
                </div>
                
                <div class="turn-timer" id="turn-timer">
                    <span class="timer-text">–ó–∞–ª–∏—à–∏–ª–æ—Å—å: <span id="time-left">02:00</span></span>
                </div>
                
                <button class="end-turn-btn" id="end-turn-btn" style="display: none;">–ó–∞–∫—ñ–Ω—á–∏—Ç–∏ —Ö—ñ–¥</button>
            </div>
            
            <!-- Right Panel - Character Stats -->
            <div class="stats-panel">
                <div class="stats-paper">
                    <!-- Page 1 -->
                    <div class="stats-page" id="stats-page-1">
                        <div class="stat-row">
                            <span class="stat-label">–°–¢–ê–¢–¨:</span>
                            <span class="stat-value" id="stat-gender">-</span>
                            <button class="reveal-indicator-btn" data-indicator="gender" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–í–Ü–ö:</span>
                            <span class="stat-value" id="stat-age">-</span>
                            <button class="reveal-indicator-btn" data-indicator="age" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–ü–†–û–§–ï–°–Ü–Ø:</span>
                            <span class="stat-value" id="stat-profession">-</span>
                            <button class="reveal-indicator-btn" data-indicator="profession" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–•–ê–†–ê–ö–¢–ï–†:</span>
                            <span class="stat-value" id="stat-character">-</span>
                            <button class="reveal-indicator-btn" data-indicator="character" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–ó–î–û–†–û–í'–Ø:</span>
                            <span class="stat-value" id="stat-health">-</span>
                            <button class="reveal-indicator-btn" data-indicator="health" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–§–û–ë–Ü–Ø:</span>
                            <span class="stat-value" id="stat-phobia">-</span>
                            <button class="reveal-indicator-btn" data-indicator="phobia" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–ù–ê–í–ò–ö:</span>
                            <span class="stat-value" id="stat-skill">-</span>
                            <button class="reveal-indicator-btn" data-indicator="skill" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–•–û–ë—ñ:</span>
                            <span class="stat-value" id="stat-hobby">-</span>
                            <button class="reveal-indicator-btn" data-indicator="hobby" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                    </div>
                    <!-- Page 2 -->
                    <div class="stats-page" id="stats-page-2" style="display: none;">
                        <div class="stat-row">
                            <span class="stat-label">–§–ê–ö–¢ 1:</span>
                            <span class="stat-value" id="stat-fact1">-</span>
                            <button class="reveal-indicator-btn" data-indicator="fact1" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–§–ê–ö–¢ 2:</span>
                            <span class="stat-value" id="stat-fact2">-</span>
                            <button class="reveal-indicator-btn" data-indicator="fact2" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–ë–ê–ì–ê–ñ:</span>
                            <span class="stat-value" id="stat-baggage">-</span>
                            <button class="reveal-indicator-btn" data-indicator="baggage" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">–ö–ê–†–¢–ê –î–Ü–á:</span>
                            <span class="stat-value" id="stat-action">-</span>
                            <button class="reveal-indicator-btn" data-indicator="action" title="–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" style="display:none;">üëÅ</button>
                        </div>
                    </div>
                    <div class="stats-pagination">
                        <button class="stats-page-btn" id="stats-prev">&lt;</button>
                        <span class="stats-page-info" id="stats-page-info">1 / 2</span>
                        <button class="stats-page-btn" id="stats-next">&gt;</button>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Skip Vote Button (shown during voting phase) -->
        <button class="skip-vote-btn" id="skip-vote-btn">–ù–µ –≥–æ–ª–æ—Å—É–≤–∞—Ç–∏</button>
        
        <!-- Results Modal -->
        <div class="modal-overlay" id="results-modal" style="display: none;">
            <div class="results-panel">
                <h2 class="results-title" id="results-title">–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≥–æ–ª–æ—Å—É–≤–∞–Ω–Ω—è</h2>
                <p class="results-text" id="results-text"></p>
                <button class="results-btn" id="results-continue">–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</button>
            </div>
        </div>
        
        <!-- Game Over Modal -->
        <div class="modal-overlay" id="gameover-modal" style="display: none;">
            <div class="gameover-panel">
                <h2 class="gameover-title">–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</h2>
                <p class="gameover-text">–í –±—É–Ω–∫–µ—Ä—ñ –∑–∞–ª–∏—à–∏–ª–∏—Å—å:</p>
                <div class="survivors-list" id="survivors-list"></div>
                <button class="gameover-btn" id="gameover-btn">–ü–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å –¥–æ –ª–æ–±—ñ</button>
            </div>
        </div>
        
        <!-- Settings Modal -->
        <div class="modal-overlay" id="settings-modal" style="display: none;">
            <div class="settings-panel">
                <h2 class="settings-title">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h2>
                <div class="setting-row">
                    <span class="setting-label">–ß—É—Ç–∏ —Å–µ–±–µ —á–µ—Ä–µ–∑ –º—ñ–∫—Ä–æ—Ñ–æ–Ω:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="hear-self-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <button class="settings-close-btn" id="settings-close">–ó–∞–∫—Ä–∏—Ç–∏</button>
            </div>
        </div>
        
        <!-- Player Volume Context Menu -->
        <div class="volume-menu" id="volume-menu" style="display: none;">
            <div class="volume-menu-header">
                <span id="volume-player-name">–ì—Ä–∞–≤–µ—Ü—å</span>
            </div>
            <div class="volume-slider-container">
                <span class="volume-icon">üîä</span>
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="100">
                <span class="volume-value" id="volume-value">100%</span>
            </div>
        </div>
        
        <!-- Loading Screen -->
        <div class="loading-screen" id="loading-screen">
            <div class="loading-background"></div>
            <div class="loading-door">
                <img src="Assets/doorloading.png" alt="Loading">
                <div class="loading-logo">
                    <img src="Assets/Component 1 (1).svg" alt="Logo">
                </div>
            </div>
        </div>
        
        <!-- Bottom Controls -->
        <div class="bottom-controls">
            <button class="control-btn exit-btn" id="exit-btn" title="–í–∏–π—Ç–∏ –∑ –≥—Ä–∏">
                <span style="font-size: 24px; color: #ff4444;">‚úñ</span>
            </button>
            <button class="control-btn mic-btn" id="mic-btn">
                <img src="Assets/ChatGPT Image 6 –¥–µ–∫. 2025 –≥., 21_21_56 1.png" alt="Microphone">
            </button>
            <button class="control-btn camera-btn" id="camera-btn">
                <img src="Assets/ChatGPT Image 6 –¥–µ–∫. 2025 –≥., 21_23_41 1.png" alt="Camera">
            </button>
            <button class="control-btn settings-btn" id="settings-btn">
                <img src="Assets/ChatGPT Image 7 –¥–µ–∫. 2025 –≥., 12_49_16 (1) 2.png" alt="Settings">
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase.js"></script>
    <script src="mediaManager.js"></script>
    <script src="webrtc.js"></script>
    <script src="gameData.js"></script>
    <script>
        // Global settings - must be initialized first
        window.hearSelfEnabled = false;
        window.playerVolumes = {};
        window.micEnabled = true;
        window.cameraEnabled = true;
        
        // Get room ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('id');
        
        let currentRoom = null;
        let currentUser = null;
        let gameState = null;
        let turnTimer = null;
        let currentPage = 0;
        let playersPerPage = 9;
        let statsPage = 0; // 0 = –æ—Å–Ω–æ–≤–Ω—ñ, 1 = –¥–æ–¥–∞—Ç–∫–æ–≤—ñ
        let webrtcManager = null;
        
        // Media manager instance
        const media = window.mediaManager;
        
        // Show loading
        document.getElementById('loading-screen').classList.add('active');
        
        // Initialize camera (—à–≤–∏–¥–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è)
        async function initCamera() {
            console.time('initCamera total');
            
            try {
                // –®–≤–∏–¥–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —á–µ—Ä–µ–∑ MediaManager
                const stream = await media.init({
                    video: true,
                    audio: true
                });
                
                if (stream) {
                    console.log('Camera initialized successfully');
                    
                    // –ü—Ä–∏–≤'—è–∑–∞—Ç–∏ –¥–æ –≤—ñ–¥–µ–æ –∫–æ–ª–∏ UI –≥–æ—Ç–æ–≤–∏–π
                    media.onStreamReady = () => {
                        attachLocalStream();
                    };
                }
                
                console.timeEnd('initCamera total');
                return stream;
                
            } catch (error) {
                console.error('Camera init error:', error);
                console.timeEnd('initCamera total');
                return null;
            }
        }
        
        // Update visibility of my video elements based on camera state
        function updateMyVideoVisibility() {
            if (!currentUser) return;
            
            const myVideo = document.getElementById(`video-${currentUser.id}`);
            if (myVideo) {
                myVideo.style.visibility = window.cameraEnabled ? 'visible' : 'hidden';
            }
            
            const speakerVideo = document.getElementById('speaker-video');
            const speaker = getCurrentSpeaker();
            if (speakerVideo && speaker && speaker.id === currentUser.id) {
                speakerVideo.style.visibility = window.cameraEnabled ? 'visible' : 'hidden';
            }
        }
        
        // Initialize WebRTC
        async function initWebRTC() {
            const client = window.supabaseAuth.initSupabase();
            webrtcManager = new WebRTCManager();
            await webrtcManager.init(client, roomId, currentUser.id);

            // Override remote stream callback
            webrtcManager.onRemoteStream = (peerId, stream) => {
                displayRemoteVideo(peerId, stream);
            };
        }

        // Display remote video in player slot
        function displayRemoteVideo(peerId, stream) {
            const videoElements = document.querySelectorAll(`[data-player-id="${peerId}"] video`);
            videoElements.forEach(video => {
                video.srcObject = stream;
            });
        }

        // Initialize game
        async function init() {
                    // –ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –∫–Ω–æ–ø–∫—É "–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫" –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–Ω—ñ –Ω–∞ —Ä—è–¥–æ–∫
                    document.querySelectorAll('.stat-row').forEach(row => {
                        row.addEventListener('mouseenter', () => {
                            const btn = row.querySelector('.reveal-indicator-btn');
                            if (btn) btn.style.display = 'inline-block';
                        });
                        row.addEventListener('mouseleave', () => {
                            const btn = row.querySelector('.reveal-indicator-btn');
                            if (btn) btn.style.display = 'none';
                        });
                    });
                    // –î—ñ—è –ø—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–∫–∞–∑–Ω–∏–∫–∞
                    document.querySelectorAll('.reveal-indicator-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const indicator = btn.getAttribute('data-indicator');
                            const value = document.getElementById('stat-' + indicator)?.textContent || '';
                            alert('–ü–æ–∫–∞–∑–Ω–∏–∫: ' + value);
                            e.stopPropagation();
                        });
                    });
            currentUser = await window.supabaseAuth.getCurrentUser();
            if (!currentUser) {
                window.location.href = 'index.html';
                return;
            }

            if (!roomId) {
                window.location.href = 'rooms.html';
                return;
            }

            await loadRoom();
            await initGameState();

            // Set user session for cleanup
            if (typeof window.require !== 'undefined') {
                const { ipcRenderer } = window.require('electron');
                ipcRenderer.send('set-user-session', {
                    userId: currentUser.id,
                    roomId: roomId
                });
            }

            await initWebRTC();
            await initCamera();
            setupRealtimeUpdates();
            setupCameraControls();

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading-screen').classList.remove('active');
            }, 1500);
        }
        
        // Load room data
        async function loadRoom() {
            const client = window.supabaseAuth.initSupabase();
            
            const { data: room, error } = await client
                .from('rooms')
                .select('*')
                .eq('id', roomId)
                .single();
            
            if (error || !room) {
                alert('–ö—ñ–º–Ω–∞—Ç–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞');
                window.location.href = 'rooms.html';
                return;
            }
            
            currentRoom = room;
        }
        
        // Initialize or load game state
        async function initGameState() {
            const client = window.supabaseAuth.initSupabase();
            
            // Check if game state exists
            const { data: existing, error: fetchError } = await client
                .from('game_states')
                .select('*')
                .eq('room_id', roomId)
                .maybeSingle();
            
            if (existing) {
                gameState = existing;
            } else {
                // Create new game state
                const players = currentRoom.players || [];
                const bunkerSlots = Math.floor(players.length / 2);
                
                // Initialize players with turn order and generated stats
                const gamePlayers = players.map((p, index) => ({
                    ...p,
                    turnOrder: index,
                    eliminated: false,
                    hasSpoken: false,
                    votes: 0,
                    stats: GameData.generatePlayerStats()
                }));
                
                // Generate bunker info
                const bunkerInfo = GameData.generateBunkerInfo(players.length);
                
                const newGameState = {
                    room_id: roomId,
                    current_round: 1,
                    current_turn: 0,
                    phase: 'speaking', // speaking, voting, results
                    bunker_slots: bunkerSlots,
                    players: gamePlayers,
                    bunker_info: bunkerInfo,
                    turn_duration: currentRoom.turn_duration || 120, // seconds
                    vote_duration: currentRoom.vote_duration || 60, // seconds
                    turn_started_at: new Date().toISOString(),
                    votes: {}
                };
                
                const { data, error } = await client
                    .from('game_states')
                    .insert(newGameState)
                    .select()
                    .single();
                
                if (error) {
                    console.error('Error creating game state:', error);
                    return;
                }
                
                gameState = data;
            }
            
            updateUI();
        }
        
        // Update UI
        function updateUI() {
            if (!gameState) return;
            
            // Update bunker slots
            document.getElementById('bunker-slots').textContent = gameState.bunker_slots;
            document.getElementById('current-round').textContent = gameState.current_round;
            
            // Get active players (not eliminated)
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            
            // Render players grid
            renderPlayersGrid(activePlayers);
            
            // Update current speaker
            updateCurrentSpeaker();
            
            // Update stats panel (show current user's stats)
            updateStatsPanel();
            
            // Show/hide end turn button
            const currentSpeaker = getCurrentSpeaker();
            const endTurnBtn = document.getElementById('end-turn-btn');
            if (currentSpeaker && currentSpeaker.id === currentUser.id && gameState.phase === 'speaking') {
                endTurnBtn.style.display = 'block';
            } else {
                endTurnBtn.style.display = 'none';
            }
            
            // Check game over
            checkGameOver();
            
            // Add/remove voting-phase class for showing vote buttons
            if (gameState.phase === 'voting') {
                document.querySelector('.game-page').classList.add('voting-phase');
                document.getElementById('skip-vote-btn').style.display = 'block';
            } else {
                document.querySelector('.game-page').classList.remove('voting-phase');
                document.getElementById('skip-vote-btn').style.display = 'none';
            }
        }
        
        // Render players grid
        function renderPlayersGrid(players) {
            const grid = document.getElementById('players-grid');
            grid.innerHTML = '';
            
            const totalPages = Math.ceil(players.length / playersPerPage);
            const startIndex = currentPage * playersPerPage;
            const endIndex = Math.min(startIndex + playersPerPage, players.length);
            const pagePlayers = players.slice(startIndex, endIndex);
            
            // Check if current user already voted
            const myVote = gameState.votes ? gameState.votes[currentUser.id] : null;
            
            pagePlayers.forEach((player, index) => {
                const isCurrentUser = player.id === currentUser.id;
                const isSpeaking = getCurrentSpeaker()?.id === player.id;
                const isVotedFor = myVote === player.id;
                
                const slot = document.createElement('div');
                slot.className = `player-slot ${isSpeaking ? 'speaking' : ''} ${player.eliminated ? 'eliminated' : ''}`;
                slot.setAttribute('data-player-id', player.id);
                
                const showVoteBtn = !player.eliminated && player.id !== currentUser.id;
                
                slot.innerHTML = `
                    <div class="player-frame">
                        <div class="player-avatar">
                            <video autoplay playsinline id="video-${player.id}"></video>
                        </div>
                        ${showVoteBtn ? `<button class="vote-btn ${isVotedFor ? 'voted' : ''}" data-player-id="${player.id}">‚úï</button>` : ''}
                    </div>
                    <span class="player-name">${isCurrentUser ? '–í–ò' : (player.name || '–ì—Ä–∞–≤–µ—Ü—å')}</span>
                `;
                
                grid.appendChild(slot);
            });
            
            // Stats pagination
            document.getElementById('stats-prev').addEventListener('click', () => {
                if (statsPage > 0) {
                    statsPage--;
                    toggleStatsPage(statsPage);
                }
            });
            document.getElementById('stats-next').addEventListener('click', () => {
                if (statsPage < 1) {
                    statsPage++;
                    toggleStatsPage(statsPage);
                }
            });
            setTimeout(() => {
                applyStoredVolumes();
            }, 100);
                // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ "–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫"
                const indicatorBtn = document.getElementById('show-indicator-btn');
                if (indicatorBtn) {
                    indicatorBtn.addEventListener('click', () => {
                        const statsPanel = document.querySelector('.stats-panel');
                        if (statsPanel) {
                            statsPanel.style.display = (statsPanel.style.display === 'none') ? 'block' : 'none';
                        }
                    });
                }
        }
        
        // Apply stored volumes to all player videos
        function applyStoredVolumes() {
            Object.entries(window.playerVolumes).forEach(([playerId, volume]) => {
                const videoElement = document.getElementById(`video-${playerId}`);
                if (videoElement) {
                    videoElement.volume = volume / 100;
                }
            });
        }
        
        // Attach local stream to user's video element
        function attachLocalStream() {
            const stream = media.localStream;
            if (!stream || !currentUser) return;
            
            const videoElement = document.getElementById(`video-${currentUser.id}`);
            if (videoElement) {
                media.attachToVideo(videoElement, {
                    muted: (window.hearSelfEnabled !== true),
                    mirror: true
                });
                // Set visibility based on camera state
                videoElement.style.visibility = (window.cameraEnabled !== false) ? 'visible' : 'hidden';
            }
        }
        
        // Update muted state for self video
        function updateSelfVideoMuted() {
            if (!currentUser) return;
            
            const shouldMute = (window.hearSelfEnabled !== true);
            console.log('updateSelfVideoMuted - hearSelfEnabled:', window.hearSelfEnabled, 'shouldMute:', shouldMute);
            
            const myVideo = document.getElementById(`video-${currentUser.id}`);
            if (myVideo) {
                myVideo.muted = shouldMute;
                console.log('My video muted set to:', shouldMute);
            }
            
            // Also update speaker video if it's current user
            const speakerVideo = document.getElementById('speaker-video');
            const speaker = getCurrentSpeaker();
            if (speakerVideo && speaker && speaker.id === currentUser.id) {
                speakerVideo.muted = shouldMute;
            }
        }
        
        // Update speaker video
        function updateSpeakerVideo() {
            const speaker = getCurrentSpeaker();
            const speakerVideo = document.getElementById('speaker-video');
            const stream = media.localStream;
            
            if (speaker && speaker.id === currentUser.id && stream) {
                media.attachToVideo(speakerVideo, {
                    muted: (window.hearSelfEnabled !== true),
                    mirror: true
                });
                speakerVideo.style.visibility = (window.cameraEnabled !== false) ? 'visible' : 'hidden';
            }
        }
        
        // Get current speaker
        function getCurrentSpeaker() {
            if (!gameState) return null;
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            return activePlayers.find(p => p.turnOrder === gameState.current_turn % activePlayers.length);
        }
        
        // Update current speaker display
        function updateCurrentSpeaker() {
            const speaker = getCurrentSpeaker();
            if (speaker) {
                document.getElementById('speaker-name').textContent = 
                    speaker.id === currentUser.id ? '–í–ò' : (speaker.name || '–ì—Ä–∞–≤–µ—Ü—å');
            }
            
            // Update timer
            updateTimer();
        }
        
        // Update timer
        function updateTimer() {
            if (!gameState || gameState.phase !== 'speaking') {
                document.getElementById('time-left').textContent = '--:--';
                return;
            }
            
            const turnStarted = new Date(gameState.turn_started_at).getTime();
            const turnDuration = gameState.turn_duration * 1000;
            const now = Date.now();
            const elapsed = now - turnStarted;
            const remaining = Math.max(0, turnDuration - elapsed);
            
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            document.getElementById('time-left').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Auto-end turn if time is up
            if (remaining <= 0) {
                const speaker = getCurrentSpeaker();
                if (speaker && speaker.id === currentUser.id) {
                    endTurn();
                }
            }
        }
        
        // Update stats panel
        function updateStatsPanel() {
            const myPlayer = gameState.players.find(p => p.id === currentUser.id);
            if (myPlayer && myPlayer.stats) {
                const stats = myPlayer.stats;
                
                // –°—Ç–æ—Ä—ñ–Ω–∫–∞ 1 - –æ—Å–Ω–æ–≤–Ω—ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
                document.getElementById('stat-gender').textContent = stats.gender || '-';
                document.getElementById('stat-age').textContent = stats.age || '-';
                document.getElementById('stat-profession').textContent = stats.profession || '-';
                document.getElementById('stat-character').textContent = stats.character || '-';
                document.getElementById('stat-health').textContent = stats.health || '-';
                document.getElementById('stat-phobia').textContent = stats.phobia || '-';
                document.getElementById('stat-skill').textContent = stats.skill || '-';
                document.getElementById('stat-hobby').textContent = stats.hobby || '-';
                
                // –°—Ç–æ—Ä—ñ–Ω–∫–∞ 2 - –¥–æ–¥–∞—Ç–∫–æ–≤—ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
                document.getElementById('stat-fact1').textContent = stats.fact1 || '-';
                document.getElementById('stat-fact2').textContent = stats.fact2 || '-';
                document.getElementById('stat-baggage').textContent = stats.baggage || '-';
                document.getElementById('stat-action').textContent = stats.actionCard || '-';
            }
        }
        
        // Toggle stats page
        function toggleStatsPage(page) {
            document.getElementById('stats-page-1').style.display = page === 0 ? 'block' : 'none';
            document.getElementById('stats-page-2').style.display = page === 1 ? 'block' : 'none';
            document.getElementById('stats-page-info').textContent = `${page + 1} / 2`;
        }
        
        // Setup camera controls
        function setupCameraControls() {
            const micBtn = document.getElementById('mic-btn');
            const cameraBtn = document.getElementById('camera-btn');
            
            // Track states globally
            window.micEnabled = true;
            window.cameraEnabled = true;
            
            micBtn.addEventListener('click', () => {
                if (webrtcManager && webrtcManager.localStream) {
                    window.micEnabled = webrtcManager.toggleMic(!window.micEnabled);
                    micBtn.classList.toggle('active', window.micEnabled);
                } else {
                    alert('–°–ø–æ—á–∞—Ç–∫—É —É–≤—ñ–º–∫–Ω—ñ—Ç—å –∫–∞–º–µ—Ä—É');
                }
            });
            
            cameraBtn.addEventListener('click', async () => {
                if (!webrtcManager.localStream) {
                    // Start camera for the first time
                    try {
                        cameraBtn.style.opacity = '0.5';
                        await webrtcManager.startCamera();
                        window.cameraEnabled = true;
                        window.micEnabled = false; // Mic is muted by default
                        cameraBtn.classList.add('active');
                        cameraBtn.style.opacity = '1';

                        // Update local video
                        updateUI();

                        // Connect to other players
                        if (currentRoom && currentRoom.players) {
                            await webrtcManager.connectToPeers(currentRoom.players);
                        }
                    } catch (error) {
                        cameraBtn.style.opacity = '1';
                        console.error('Camera error:', error);
                        if (error.name === 'NotAllowedError') {
                            alert('–î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ. –î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö.');
                        } else if (error.name === 'NotFoundError') {
                            alert('–ö–∞–º–µ—Ä–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.');
                        } else if (error.name === 'AbortError' || error.name === 'NotReadableError') {
                            alert('–ö–∞–º–µ—Ä–∞ –∑–∞–π–Ω—è—Ç–∞ —ñ–Ω—à–æ—é –ø—Ä–æ–≥—Ä–∞–º–æ—é. –ó–∞–∫—Ä–∏–π—Ç–µ —ñ–Ω—à—ñ –ø—Ä–æ–≥—Ä–∞–º–∏ —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å –∫–∞–º–µ—Ä—É.');
                        } else {
                            alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏: ' + error.message);
                        }
                    }
                } else {
                    // Toggle camera
                    window.cameraEnabled = webrtcManager.toggleCamera(!window.cameraEnabled);
                    cameraBtn.classList.toggle('active', window.cameraEnabled);

                    // Hide/show all my video elements
                    updateMyVideoVisibility();
                    console.log('Camera toggled:', window.cameraEnabled);
                }
            });
            
            // Exit button - leave game
            document.getElementById('exit-btn').addEventListener('click', async () => {
                if (confirm('–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ —â–æ —Ö–æ—á–µ—Ç–µ –≤–∏–π—Ç–∏ –∑ –≥—Ä–∏?')) {
                    // Clear user session before leaving
                    if (typeof window.require !== 'undefined') {
                        const { ipcRenderer } = window.require('electron');
                        ipcRenderer.send('clear-user-session');
                    }
                    await leaveRoomAndCleanup();
                    window.location.href = 'rooms.html';
                }
            });
            
            // Settings modal
            document.getElementById('settings-btn').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'flex';
            });
            
            document.getElementById('settings-close').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'none';
            });
            
            // Hear self toggle
            const hearSelfToggle = document.getElementById('hear-self-toggle');
            hearSelfToggle.addEventListener('change', (e) => {
                window.hearSelfEnabled = e.target.checked;
                console.log('Hear self toggled:', window.hearSelfEnabled);
                updateSelfVideoMuted();
            });
            
            // Stats pagination
            document.getElementById('stats-prev').addEventListener('click', () => {
                if (statsPage > 0) {
                    statsPage--;
                    toggleStatsPage(statsPage);
                }
            });
            
            document.getElementById('stats-next').addEventListener('click', () => {
                if (statsPage < 1) {
                    statsPage++;
                    toggleStatsPage(statsPage);
                }
            });
            
            // Player volume context menu
            const volumeMenu = document.getElementById('volume-menu');
            const volumeSlider = document.getElementById('volume-slider');
            let selectedPlayerId = null;
            
            // Right-click on player frame
            document.addEventListener('contextmenu', (e) => {
                const playerSlot = e.target.closest('.player-slot');
                if (playerSlot) {
                    e.preventDefault();
                    const playerId = playerSlot.getAttribute('data-player-id');
                    if (playerId && playerId !== currentUser.id) {
                        selectedPlayerId = playerId;
                        const player = gameState.players.find(p => p.id === playerId);
                        document.getElementById('volume-player-name').textContent = player?.name || '–ì—Ä–∞–≤–µ—Ü—å';
                        
                        // Get stored volume or default to 100
                        const currentVolume = window.playerVolumes[playerId] ?? 100;
                        volumeSlider.value = currentVolume;
                        document.getElementById('volume-value').textContent = currentVolume + '%';
                        
                        volumeMenu.style.display = 'block';
                        volumeMenu.style.left = e.pageX + 'px';
                        volumeMenu.style.top = e.pageY + 'px';
                    }
                }
            });
            
            // Volume slider change
            volumeSlider.addEventListener('input', (e) => {
                const volume = e.target.value;
                document.getElementById('volume-value').textContent = volume + '%';
                
                if (selectedPlayerId) {
                    window.playerVolumes[selectedPlayerId] = volume;
                    const videoElement = document.getElementById(`video-${selectedPlayerId}`);
                    if (videoElement) {
                        videoElement.volume = volume / 100;
                    }
                }
            });
            
            // Close volume menu on click outside
            document.addEventListener('click', (e) => {
                if (!volumeMenu.contains(e.target)) {
                    volumeMenu.style.display = 'none';
                }
            });
        }
        
        // End turn
        async function endTurn() {
            const client = window.supabaseAuth.initSupabase();
            
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            const currentTurn = gameState.current_turn;
            const nextTurn = currentTurn + 1;
            
            // Check if round is complete
            if (nextTurn >= activePlayers.length) {
                // Move to voting phase
                await client
                    .from('game_states')
                    .update({ 
                        phase: 'voting',
                        votes: {}
                    })
                    .eq('id', gameState.id);
            } else {
                // Next player's turn
                await client
                    .from('game_states')
                    .update({ 
                        current_turn: nextTurn,
                        turn_started_at: new Date().toISOString()
                    })
                    .eq('id', gameState.id);
            }
        }
        
        // Cast vote
        async function castVote(playerId) {
            const client = window.supabaseAuth.initSupabase();
            
            const votes = { ...gameState.votes };
            votes[currentUser.id] = playerId;
            
            await client
                .from('game_states')
                .update({ votes: votes })
                .eq('id', gameState.id);
            
            // Check if all players voted
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            if (Object.keys(votes).length >= activePlayers.length) {
                await processVotes();
            }
        }
        
        // Process votes
        async function processVotes() {
            const client = window.supabaseAuth.initSupabase();
            
            // Count votes
            const voteCount = {};
            Object.values(gameState.votes).forEach(votedId => {
                if (votedId) {
                    voteCount[votedId] = (voteCount[votedId] || 0) + 1;
                }
            });
            
            // Find player with most votes
            let maxVotes = 0;
            let eliminatedId = null;
            Object.entries(voteCount).forEach(([playerId, count]) => {
                if (count > maxVotes) {
                    maxVotes = count;
                    eliminatedId = playerId;
                }
            });
            
            // Eliminate player
            if (eliminatedId) {
                const updatedPlayers = gameState.players.map(p => {
                    if (p.id === eliminatedId) {
                        return { ...p, eliminated: true };
                    }
                    return p;
                });
                
                // Start next round
                await client
                    .from('game_states')
                    .update({ 
                        players: updatedPlayers,
                        current_round: gameState.current_round + 1,
                        current_turn: 0,
                        phase: 'speaking',
                        turn_started_at: new Date().toISOString(),
                        votes: {}
                    })
                    .eq('id', gameState.id);
            }
        }
        
        // Check game over
        function checkGameOver() {
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            if (activePlayers.length <= gameState.bunker_slots) {
                showGameOver(activePlayers);
            }
        }
        
        // Show game over
        function showGameOver(survivors) {
            const modal = document.getElementById('gameover-modal');
            const list = document.getElementById('survivors-list');
            
            list.innerHTML = survivors.map(p => `
                <div class="survivor-item">${p.name || '–ì—Ä–∞–≤–µ—Ü—å'}</div>
            `).join('');
            
            modal.style.display = 'flex';
        }
        
        // Setup realtime updates
        function setupRealtimeUpdates() {
            const client = window.supabaseAuth.initSupabase();
            
            client
                .channel('game-' + roomId)
                .on('postgres_changes', { 
                    event: '*', 
                    schema: 'public', 
                    table: 'game_states',
                    filter: `room_id=eq.${roomId}`
                }, (payload) => {
                    gameState = payload.new;
                    updateUI();
                })
                .subscribe();
            
            // Timer update interval
            setInterval(updateTimer, 1000);
        }
        
        // Event listeners
        document.getElementById('end-turn-btn').addEventListener('click', endTurn);
        
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                updateUI();
            }
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            const activePlayers = gameState.players.filter(p => !p.eliminated);
            const totalPages = Math.ceil(activePlayers.length / playersPerPage);
            if (currentPage < totalPages - 1) {
                currentPage++;
                updateUI();
            }
        });
        
        document.getElementById('skip-vote-btn').addEventListener('click', () => castVote(null));
        
        document.getElementById('gameover-btn').addEventListener('click', () => {
            // Clear user session when game ends
            if (typeof window.require !== 'undefined') {
                const { ipcRenderer } = window.require('electron');
                ipcRenderer.send('clear-user-session');
            }
            window.location.href = 'rooms.html';
        });
        
        document.getElementById('results-continue').addEventListener('click', () => {
            document.getElementById('results-modal').style.display = 'none';
        });
        
        // Leave room and cleanup on page unload
        async function leaveRoomAndCleanup() {
            if (!currentUser || !roomId) return;

            const client = window.supabaseAuth.initSupabase();

            try {
                // Get current room data
                const { data: room } = await client
                    .from('rooms')
                    .select('players, host_id')
                    .eq('id', roomId)
                    .single();

                if (room && room.players) {
                    const players = room.players.filter(p => p.id !== currentUser.id);

                    if (players.length === 0) {
                        // Delete room and game state if empty
                        await client.from('game_states').delete().eq('room_id', roomId);
                        await client.from('rooms').delete().eq('id', roomId);
                        console.log('Room deleted (0 players)');
                    } else {
                        // Update players list
                        const updates = { players: players };

                        // Transfer host if leaving player was host
                        if (room.host_id === currentUser.id) {
                            updates.host_id = players[0].id;
                        }

                        await client.from('rooms').update(updates).eq('id', roomId);
                    }
                }

                // Clear user session
                if (typeof window.require !== 'undefined') {
                    const { ipcRenderer } = window.require('electron');
                    ipcRenderer.send('clear-user-session');
                }

                // Close WebRTC connections
                if (webrtcManager) {
                    webrtcManager.closeAllConnections();
                }

                // Stop camera/mic via MediaManager
                media.stop();
            } catch (err) {
                console.error('Leave room error:', err);
            }
        }
        
        // Cleanup on page unload (close/reload/navigate away)
        let isUnloading = false;
        window.addEventListener('beforeunload', (event) => {
            if (currentUser && roomId && !isUnloading) {
                isUnloading = true;
                leaveRoomAndCleanup();
            }
        });
        
        init();
    </script>
</body>
</html>